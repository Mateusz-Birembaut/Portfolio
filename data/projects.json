{
  "projects": [

    {
      "slug": "orcoeur",
      "title": "OrCoeur – Simplification de maillages 3D hors mémoire",
      "summary": "Outil avancé de simplification, découpe et conversion de maillages 3D, avec interface graphique et visualisation interactive.",
      "description": "Le projet intègre des techniques d’optimisation de l’utilisation de la mémoire lors du traitement des maillages 3D. L’algorithme de tri (merge sort) est implémenté pour minimiser les allocations temporaires et garantir une gestion efficace des structures volumineuses. D’autres optimisations incluent l’utilisation de structures de données compactes, la réduction des copies inutiles, et le recours à des passes de dereferencement pour limiter la fragmentation mémoire. Ces choix permettent de traiter des maillages de grande taille tout en maintenant de bonnes performances et une faible empreinte mémoire. Le logiciel propose la simplification adaptative, la découpe, la conversion de formats et la visualisation interactive via ImGui et Polyscope.",
      "status": "Terminé",
      "tags": ["3D", "Maillage", "Simplification", "Optimisation mémoire", "Visualisation", "ImGui", "Polyscope", "C++"],
      "tech": ["C++", "ImGui", "Polyscope", "Eigen", "CMake"],
  "contributors": ["donovan", "hugo", "mateusz"],
      "github": "https://github.com/horscoeur/OrCoeur/tree/stream/write", 
      "media": [
        { "type": "image", "src": "assets/projects/Orcoeur/simplification.png", "caption": "Comparaison de la simplification entre 2 algorithmes" },
        { "type": "image", "src": "assets/projects/Orcoeur/simplification2.png", "caption": "Simplification de maillages de 4.7GB" },
        { "type": "pdf", "src": "assets/projects/Orcoeur/Rapport_Orcoeur.pdf", "caption": "Rapport" }
      ]
    }, 

    {
      "slug": "tp-algorithmes",
      "title": "Ray Tracer",
      "summary": "Moteur de rendu 3D par lancer de rayons, accéléré par multi-threading et Kd-Tree et Bounding Boxes.",
      "description": "Développement d’un ray tracer CPU en C++ avec interface graphique ImGui et rendu OpenGL. Gestion avancée des matériaux (textures, normal maps), import de maillages OFF, génération d’images photo-réalistes (PPM/PNG). Optimisation des performances via structures d’accélération (Kd-Tree, Bounding Boxes).",
      "status": "Terminé",
      "tags": ["3D", "Rendu", "Ray Tracing", "Optimisation", "ImGui", "OpenGL", "C++"],
      "tech": ["C++", "OpenGL", "ImGui"],
  "contributors": ["mateusz"],
      "github": "https://github.com/Mateusz-Birembaut/HAI719I-Programmation-3D/tree/main/Projet-Ray_Tracer",
      "media": [
        { "type": "image", "src": "assets/projects/ray_tracer/rendu.png", "caption": "Aperçu du rendu avec photon mapping" },
        { "type": "pdf", "src": "assets/projects/ray_tracer/Ray_tracer_Mateusz_BIREMBAUT.pdf", "caption": "Rapport" }
      ]
    },


    {
        "slug": "vulkan-tutorial-implementation",
        "title": "Personnel -- Implémentation Vulkan Tutorial - Alexander Overvoorde",
        "summary": "Implémentation du tutoriel Vulkan officiel en C++ avec gestion des buffers, pipelines graphiques, uniform buffers et rendu d'objets 3D avec matrices de transformation.",
        "description": "Ce projet est une implémentation du tutoriel vulkan-tutorial.com, développée en C++. Il couvre tous les aspects fondamentaux de l'API Vulkan : création d'instance, sélection de périphériques physiques, création de logical devices avec gestion des queue families (graphics, present, transfer), mise en place de la swap chain, création des render passes et pipelines graphiques. L'application implémente un système de rendu moderne avec vertex et index buffers combinés dans un mesh buffer unifié, uniform buffers pour les matrices de transformation (model, view, projection), descriptor sets pour lier les ressources aux shaders, et synchronisation GPU/CPU avec semaphores et fences. Le projet inclut également la gestion du redimensionnement de fenêtre, le double buffering, et l'optimisation des transferts mémoire avec staging buffers.",
        "status": "En cours",
        "tags": ["Vulkan", "Rendu 3D", "C++", "API graphique", "Pipeline graphique", "Shaders", "Buffers", "Synchronisation GPU", "Tutorial officiel"],
        "tech": ["C++", "Vulkan API", "GLFW", "GLM", "SPIR-V", "CMake"],
        "contributors": ["mateusz"],
        "github": "https://github.com/Mateusz-Birembaut/vulkan-tutorial",
        "website": "https://vulkan-tutorial.com/",
      "media": [
        { "type": "image", "src": "assets/projects/vkTuto/example.png", "caption": "Aperçu de l'avancée actuelle" }
      ]
    },

    	{
		"slug": "projet-compression-4k",
		"title": "Compresseur universel d’images 4K",
		"summary": "Application de compression d’images 4K en C++ avec interface Qt, utilisant des algorithmes de superpixels (SLIC, SDGT), Analyse du PSNR pour quantifier les résultats.",
		"description": "Ce projet propose un compresseur d’images 4K développé en C++ avec une interface graphique Qt. Il intègre des algorithmes de segmentation en superpixels (SLIC, SDGT), permet de calculer le PSNR et le taux de compression, et de comparer les deux images côte à côte pour observer les résultats de la compression. La compilation est gérée par CMake et OpenCV est utilisé pour le traitement d’images.",
		"status": "Terminé",
		"tags": ["Compression", "Image 4K", "Superpixels", "Qt", "OpenCV", "C++"],
		"tech": ["C++", "Qt", "OpenCV", "CMake"],
    "contributors": ["vincent" ,"mateusz"],
		"github": "https://github.com/vincent-bernardon/projet-compression-4K",
		"media": [
      { "type": "image", "src": "assets/projects/compression4k/resultat.png", "caption": "Compression SLIC avec peu de super pixels" },
			{ "type": "image", "src": "assets/projects/compression4k/exempleCompression2.png", "caption": "Interface et compression d'une image" }
		]
	},

	{
		"slug": "luigiengine",
		"title": "LuigiEngine – Moteur de jeu 3D from scratch en C++ et OpenGL",
		"summary": "Moteur 3D pour jeux de course en C++/OpenGL, avec ECS, rendu PBR, physique et collision, personnalisation de circuits, audio et outils de debug interactifs.",
		"description": "LuigiEngine est un moteur de jeu (jeu de course) 3D développé en C++ intégrant un système ECS modulaire, un pipeline de rendu OpenGL/GLSL, la possibilité de modifié le tracé du circuit dans le moteur avec une courbe de Catmull-Rom et des points de contrôles. Il propose une physique temps réel avec détection de collisions (AABB, OBB, sphère, cylindre, raycast), possibilité de jouer des sons via miniaudio, et une interface de debug et d’édition interactive basée sur ImGui docking. La compilation est gérée par CMake.",
		"status": "Terminé",
		"tags": ["3D", "Moteur de jeu", "ECS", "Physique", "OpenGL", "Audio", "ImGui", "C++"],
		"tech": ["C++", "OpenGL", "GLSL", "ImGui", "miniaudio", "CMake"],
    "contributors": ["remy", "arthur","mateusz"],
		"github": "https://github.com/Rashnain/LuigiEngine",
		"media": [
      { "type": "image", "src": "assets/projects/luigiEngine/test.png", "caption": "" },
			{ "type": "video", "src": "assets/projects/luigiEngine/test_physique.mp4", "poster": "assets/projects/luigiengine/poster.jpg", "caption": "Démo"  },
      { "type": "image", "src": "assets/projects/luigiEngine/modification_circuit.png", "caption": "Aperçu de la modification du circuit" }
		]
	},



    {
        "slug": "particle-system-spatiotemporal-data",
        "title": "Système à particules pour visualisation de données spatio-temporelles",
        "summary": "Application web de visualisation interactive utilisant des systèmes à particules pour représenter différents phénomènes : cartes de vent, simulations physiques, effets de feu, feux d'artifice et structures arborescentes.",
        "description": "Ce projet propose un système de visualisation de données spatio-temporelles développé en JavaScript avec Node.js et Express. Il implémente plusieurs types de simulations à particules : visualisation de cartes météorologiques (windmap), visualisation des votes lors d'élections, effets visuels de feu et feux d'artifice, et génération de structures arborescentes. L'application offre une interface web interactive avec des contrôles en temps réel pour ajuster les paramètres des simulations (nombre de particules, vitesse, durée de vie, etc.).",
        "status": "Terminé",
        "tags": ["Système à particules", "Visualisation de données", "JavaScript", "Canvas", "Simulation physique", "Données météorologiques", "Interface web interactive"],
        "tech": ["JavaScript", "Node.js", "Express", "HTML5 Canvas", "EJS", "CSS3"],
        "contributors": ["jules", "mateusz"],
        "github": "https://github.com/JMarguery/ParticleSystemPP2GroupH",
      "media": [
        { "type": "image", "src": "assets/projects/particleSystem/windmap.png", "caption": "Aperçu d'un des système a particule" },
        { "type": "pdf", "src": "assets/projects/particleSystem/rapport.pdf", "caption": "Rapport" }
      ]
    }

  ]


}